@page "/"
@using drgndrop;
@using SevenZip;
@inject IWebHostEnvironment Environment
@inject NavigationManager NavManager
@inject IClipboardService ClipboardService
@inject IJSRuntime JS

<PageTitle>Index</PageTitle>

<div class="container">
    @{
        <h1>Drgndrop</h1>

        if(!Finished)
        {
            if (!Uploading)
            {
                <div class="new-line"></div>
                <form>
                    <div class="new-line"></div>
                    <InputFile OnChange="@UploadFiles" />
                    <div class="new-line"></div>
                    <input type="checkbox" id="encrypt" @bind="@Encrypted"/>
                    <label for="encrypt">Encrypt</label>
                </form>
            }
            else
            {
                <div class="new-line"></div>
                <LoadingTemplate>
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    Uploading...
                </LoadingTemplate>
                <div class="new-line"></div>
                <p>@(Utils.BytesToMB(UploadedBytes, 2))MB / @(Utils.BytesToMB(DroppedFile.Size, 2))MB</p>
            }
        }
    }

    @if (Errored)
    {
        <div class="new-line"></div>
        <p>Error: @ErrorMsg</p>
    }

    @if(Finished)
    {
        @if (!Errored)
        {
            <div class="new-line"></div>
            <div class="container">
                @if(AutoCopied){ <p>Link automatically copied to clipboard</p> }
                <div class="new-line"></div>
                <input type="text" id="link" @bind="@LinkToFile" size="64" style="width:100%" readonly />
            </div>
        }

        @if(!Uploading)
        {
            <div class="new-line"></div>
            <button onclick="@ResetState">Upload Another</button>
        }
    }
</div>


@code
{
    public string ErrorMsg = "";
    public bool Errored => ErrorMsg != "";
    public bool Uploading = false;
    private bool Encrypted = true;
    private int UploadedBytes = 0;
    private string LinkToFile = "";
    private bool AutoCopied = false;
    public bool Finished = false;
    public IBrowserFile DroppedFile = null;

    public string FileID = "";
    public string FileExt => Utils.GetExtension(DroppedFile.Name);
    public string FileName => $"{FileID}.{FileExt}";
    public string Password = "";
    public string FilePath => Path.Combine(Program.UploadPath, FileName);
    public Timer Timer = null;

    public void ResetState()
    {
        AutoCopied = false;
        ErrorMsg = "";
        Uploading = false;
        Finished = false;
        UploadedBytes = 0;

        DroppedFile = null;

        Password = "";
    }

    async Task UploadFiles(InputFileChangeEventArgs e)
    {
        ResetState();

        var files = e.GetMultipleFiles();

        if(files.Count > 1)
        {
            ErrorMsg = $"Currently only one file per upload is allowed!";
            Uploading = false;
            return;
        }

        DroppedFile = files[0];
        var drgnfile = GenerateNewFile();

        await using var Timer = new Timer(_ => InvokeAsync(() => StateHasChanged()));
        Timer.Change(TimeSpan.FromMilliseconds(1000), TimeSpan.FromMilliseconds(1000));

        ProcessFile(drgnfile);
        CopyToClipboard();

        Timer.Dispose();
        Uploading = false;
        Finished = true;
    }

    public Drgnfile GenerateNewFile()
    {
        FileID = Utils.GenID();
        if(Encrypted) Password = Utils.GenPass();

        return new Drgnfile(DroppedFile.Name, Password ?? "");
    }

    public async void ProcessFile(Drgnfile drgnfile)
    {
        Uploading = true;

        try
        {
            if (DroppedFile.Size >= Program.MaxFileSize)
            {
                ErrorMsg = $"One or more file sizes are too big ({DroppedFile.Name})! The size limit is {Utils.BytesToMB(Program.MaxFileSize)} MB per file.";
                throw new InvalidOperationException(ErrorMsg);
            }

            using var rs = DroppedFile.OpenReadStream(Program.MaxFileSize);
            var uploadStream = new MemoryStream();
            var dataStream = new MemoryStream();
            byte[] buffer = new byte[rs.Length];

            while (await rs.ReadAsync(buffer, 0, (int)rs.Length) is int read && read > 0)
            {
                UploadedBytes += read;
                uploadStream.Write(buffer, 0, read);
            }

            uploadStream.Position = 0;

            if (Encrypted) await Program.Compressor.CompressStreamAsync(uploadStream, dataStream, Password);
            else await Program.Compressor.CompressStreamAsync(uploadStream, dataStream);


            drgnfile.Write(dataStream);

            dataStream.Close();
            uploadStream.Close();
        }
        catch (Exception ex)
        {
            ErrorMsg = ex.Message;

            Timer?.Dispose();
            if (File.Exists(FilePath)) File.Delete(FilePath);

            Uploading = false;
            Finished = true;
            return;
        }
        finally
        {
            drgnfile.Save(FilePath);
        }
    }

    public async void CopyToClipboard()
    {
        if (Encrypted) LinkToFile = Utils.GenLink($"files/{FileName}?key={Password}");
        else LinkToFile = Utils.GenLink($"files/{FileName}");

        if (await JS.InvokeAsync<bool>("document.hasFocus"))
        {
            try
            {
                await ClipboardService.CopyToClipboard(LinkToFile);
                AutoCopied = true;
            }
            catch (Exception ex)
            {
                ErrorMsg = "Access denied to clipboard! Must manually copy.";
                AutoCopied = false;
            }
        }
        else
        {
            AutoCopied = false;
        }
    }
}